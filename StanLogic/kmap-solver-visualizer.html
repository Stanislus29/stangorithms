<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StanLogic - KMapSolver (Viz)</title>
    <style>
        /* --- Brand palette (from animation.html) --- */
        :root {
            --bg-page: #fdfbf5;
            --text-dark: #1a2942;
            --text-light: #fdfbf5;
            --brand-primary: #1a2942;
            --brand-secondary: #c19a6b; /* A complementary tan/gold */
            --panel-bg: #1a2942;
            --panel-border: #d4c5a9;
            --shadow-elev: 0 8px 25px rgba(26, 41, 66, 0.15);
        }
        /* Single background (remove dual look) - REMOVED CONFLICTING BODY STYLE */

        /* Container restyled: transparent overlay card feel */
        .container {
            background: rgba(255,255,255,0.6);
            border: 1px solid var(--panel-border);
            box-shadow: var(--shadow-elev);
        }
        h1 {
            color: var(--text-dark);
            font-family: 'Georgia', 'Times New Roman', serif;
        }
        .subtitle {
            color: #5a677d;
        }
        /* Info / step panels adopt brand accents */
        .info-box {
            background: #eef3fA;
            border-left: 4px solid var(--brand-primary);
            color: var(--text-dark);
        }
        .error {
            background: #fbe9e7;
            border-left-color: #c62828;
            color: #c62828;
        }
        .step-container {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-left: 4px solid var(--brand-primary);
            color: var(--text-dark);
        }
        .step-title {
            color: var(--text-dark);
        }
        .step-title {
            color: var(--text-primary);
        }
        .result {
            background: linear-gradient(135deg, #4ea1ff 0%, #2d3e50 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-size: 1.3em;
            text-align: center;
            font-weight: 600;
        }
        .btn-success {
            background: #7ee787;
            color: #0b1220;
        }
        .btn-success:hover {
            background: #96f6a4;
        }
        /* Logo block */
        .brand-header {
            display: flex;
            flex-direction: column; /* CHANGED for vertical alignment */
            align-items: center;
            gap: 10px; /* REDUCED gap */
            margin-bottom: 30px; /* INCREASED space below header */
            text-align: center; /* Center-align text */
        }
        .brand-header img {
            width:90px;
            height:auto;
            filter:drop-shadow(0 4px 10px rgba(0,0,0,.45));
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            /* REPLACED: old linear-gradient */
            background: radial-gradient(1600px 1200px at 25% 8%, #12203a 0%, #0b1220 58%, #070d17 100%);
            color: #e9eef8;
            min-height: 100vh;
            padding: 0; /* REMOVED padding */
        }

        .container {
            width: 100%; /* CHANGED from max-width */
            min-height: 100vh; /* ADDED to fill height */
            margin: 0; /* REMOVED auto margin */
            /* REPLACED background + border colors */
            background: transparent; /* CHANGED to transparent */
            border: none; /* REMOVED border */
            padding: 30px;
            box-shadow: none; /* REMOVED shadow */
        }

        h1 {
            text-align: center;
            color: #e9eef8;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #a8b3c7;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: #0b1832;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #d4c5a9;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            color: #e9eef8;
            margin-bottom: 10px;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .btn-primary {
            background: #1a2942;
            color: white;
        }

        .btn-primary:hover {
            background: #2d3e50;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #e0e0e0;
            color: #1a2942;
        }

        .btn-secondary:hover {
            background: #d0d0d0;
        }

        .btn-secondary.active {
            background: #1a2942;
            color: white;
        }

        .btn-success {
            background: #7ee787;
            color: #0b1220;
        }

        .btn-success:hover {
            background: #96f6a4;
        }

        .btn-replay {
            background: #c19a6b;
            color: #1a2942;
            padding: 8px 16px;
            font-size: 13px;
            margin-top: 10px;
        }

        .btn-replay:hover {
            background: #d4a574;
        }

        .kmap-container {
            background: transparent; /* CHANGED from white */
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            border: none; /* REMOVED border */
        }

        .kmap-wrapper {
            position: relative;
        }

        .cluster-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .cluster-rect {
            fill: none;
            stroke-width: 4;
            rx: 8;
            ry: 8;
            animation: clusterDraw 0.8s ease-in-out forwards;
            fill-opacity: 0.2; /* ADDED for semi-transparent fill */
        }

        .cluster-rect.group-color {
            stroke: #a8b3c7; /* CHANGED from #1a2942 */
            fill: #a8b3c7; /* ADDED fill */
            stroke-opacity: 0.8;
        }

        .cluster-rect.essential-color {
            stroke: #7ee787; /* CHANGED from #2d5016 */
            fill: #7ee787; /* ADDED fill */
            stroke-opacity: 0.9;
        }

        .cluster-rect.final-color {
            stroke: #e9eef8; /* CHANGED from #96f6a4 */
            fill: #e9eef8; /* CHANGED from #96f6a4 */
            stroke-width: 5;
            stroke-opacity: 1;
        }

        .cluster-rect.covered-color {
            stroke: #4ea1ff; /* CHANGED from #1a2942 */
            fill: #4ea1ff; /* ADDED fill */
            stroke-opacity: 0.7; /* Increased opacity */
            stroke-dasharray: 10 5;
        }

        @keyframes clusterDraw {
            0% {
                stroke-dasharray: 1000;
                stroke-dashoffset: 1000;
            }
            100% {
                stroke-dasharray: 1000;
                stroke-dashoffset: 0;
            }
        }

        .kmap-labels {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
            padding-left: 50px;
        }

        .kmap-label {
            width: 60px;
            text-align: center;
            font-weight: 600;
            color: #e9eef8; /* CHANGED from #a8b3c7 for brighter text */
        }

        .kmap-row {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
        }

        .row-label {
            width: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: #e9eef8; /* CHANGED from #a8b3c7 for brighter text */
        }

        .kmap-cell {
            width: 60px;
            height: 60px;
            border: 2px solid #4a5a75; /* CHANGED border color */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            background: transparent; /* CHANGED from white */
            transition: all 0.2s ease;
            border-radius: 5px;
            position: relative;
            color: #f05545; /* Default color for '0' */
        }

        .kmap-cell:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(26, 41, 66, 0.3);
            border-color: #c19a6b;
        }

        .kmap-cell.one {
            background: transparent; /* REMOVED #e8f5e9 */
            color: #7ee787;
        }

        .kmap-cell.zero {
            background: transparent; /* REMOVED #ffebee */
            color: #f05545;
        }

        .kmap-cell.dontcare {
            background: transparent; /* REMOVED #fff9c4 */
            color: #ffc93c;
        }

        .kmap-cell.grouped {
            box-shadow: inset 0 0 0 4px rgba(26, 41, 66, 0.6);
        }

        .visualization {
            /* REMOVED background, padding, border, and border-radius */
            margin-bottom: 20px;
        }

        .step-container {
            margin-bottom: 20px;
            padding: 15px;
            background: #0b1832;
            border-radius: 8px;
            border: 1px solid #1b2f55; /* ADDED border for separation */
        }

        .step-title {
            font-weight: 600;
            color: #e9eef8;
            margin-bottom: 10px;
            font-size: 1.2em;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .step-content {
            color: #a8b3c7;
            line-height: 1.6;
        }

        .animated-kmap {
            margin: 20px 0;
            padding: 20px;
            background: transparent; /* CHANGED from white */
            border-radius: 8px;
            display: flex;
            justify-content: center;
            border: none; /* REMOVED border */
        }

        .animated-kmap .kmap-wrapper {
            transform: scale(0.85);
        }

        .animated-kmap .kmap-cell {
            transition: all 0.5s ease;
            background: transparent; /* CHANGED from white */
            color: #f05545; /* Default color for '0' */
        }

        .animated-kmap .kmap-cell.one {
            background: transparent; /* REMOVED #e8f5e9 */
            color: #7ee787;
        }

        .animated-kmap .kmap-cell.zero {
            background: transparent; /* REMOVED #ffebee */
            color: #f05545;
        }

        .animated-kmap .kmap-cell.dontcare {
            background: transparent; /* REMOVED #fff9c4 */
            color: #ffc93c;
        }

        .kmap-cell.highlight-pulse {
            animation: pulse 1s ease-in-out;
        }

        .kmap-cell.grouped-animated {
            animation: groupHighlight 0.8s ease-in-out forwards;
            box-shadow: none;
        }

        .kmap-cell.essential-animated {
            animation: essentialHighlight 1s ease-in-out forwards;
            box-shadow: none;
        }

        .kmap-cell.covered-animated {
            animation: coveredHighlight 0.8s ease-in-out forwards;
            box-shadow: none;
        }

        .kmap-cell.filtering-out {
            animation: fadeOut 0.8s ease-in-out forwards;
        }

        .kmap-cell.final-cluster {
            box-shadow: none;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); box-shadow: 0 0 20px rgba(26, 41, 66, 0.8); }
        }

        @keyframes groupHighlight {
            0% { 
                box-shadow: inset 0 0 0 0px rgba(26, 41, 66, 0);
                transform: scale(1);
            }
            50% { 
                transform: scale(1.1);
            }
            100% { 
                box-shadow: inset 0 0 0 4px rgba(26, 41, 66, 0.8);
                transform: scale(1);
            }
        }

        @keyframes essentialHighlight {
            0% { 
                box-shadow: inset 0 0 0 0px rgba(45, 80, 22, 0);
            }
            50% { 
                transform: scale(1.1);
            }
            100% { 
                box-shadow: inset 0 0 0 5px rgba(45, 80, 22, 0.9);
                border-color: #2d5016;
                transform: scale(1);
            }
        }

        @keyframes coveredHighlight {
            0% { 
                opacity: 1;
            }
            50% { 
                transform: scale(1.1);
                opacity: 0.7;
            }
            100% { 
                box-shadow: inset 0 0 0 3px rgba(26, 41, 66, 0.5);
                opacity: 0.85;
                transform: scale(1);
            }
        }

        @keyframes fadeOut {
            0% { 
                opacity: 1;
                transform: scale(1);
            }
            100% { 
                opacity: 0.2;
                transform: scale(0.9);
                filter: grayscale(100%);
            }
        }

        .animation-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }

        .animation-label {
            display: inline-block;
            padding: 5px 12px;
            background: #1a2942;
            color: white;
            border-radius: 15px;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 10px;
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .group-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .group-item {
            padding: 8px 15px;
            background: #1a2942;
            color: white;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .group-item:hover {
            background: #2d3e50;
            transform: scale(1.05);
        }

        .group-item.essential {
            background: #2d5016;
        }

        .result {
            background: linear-gradient(135deg, #4ea1ff 0%, #2d3e50 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-size: 1.3em;
            text-align: center;
            font-weight: 600;
        }

        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-box {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            border: 2px solid #1a2942;
        }

        .info-box {
            background: #0b1832;
            border-left: 4px solid #4ea1ff;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
            color: #e9eef8;
        }

        .error {
            background: #2a1120;
            border-left: 4px solid #c62828;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
            color: #c62828;
        }

        .cluster-visualization {
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 2px solid #d4c5a9;
        }

        .cluster-label {
            font-weight: 600;
            color: #1a2942;
            margin-bottom: 10px;
        }

        /* Optional: class if you want different styling for wrap rectangles (not required) */
        .cluster-rect.wrap {
            stroke-linejoin: round;
        }

        .footer {
            border-top: 1px dashed #1c325d;
            padding-top: 20px;
            margin-top: 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #a8b3c7;
            font-size: 14px;
        }
        .footer-links {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        .footer-links a {
            color: #a8b3c7;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: color 0.3s ease;
        }
        .footer-links a:hover {
            color: #e9eef8;
        }
        .footer-links img {
            width: 20px;
            height: 20px;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }
            
            .kmap-cell {
                width: 50px;
                height: 50px;
                font-size: 16px;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
        }

        /* ADDED: persistent coverage viz styles */
        .cell-badges {
            position: absolute;
            right: 3px;
            bottom: 3px;
            display: flex;
            gap: 3px;
            flex-wrap: wrap;
            max-width: calc(100% - 6px);
            pointer-events: none;
        }
        .prime-badge {
            background: #1a2942;
            border: 1px solid #4ea1ff;
            color: #e9eef8;
            font-size: 10px;
            line-height: 14px;
            height: 16px;
            min-width: 16px;
            padding: 0 4px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,.35);
            pointer-events: auto; /* allow tooltip hover */
            cursor: default;
        }
        .coverage-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Brand header with logo + text -->
        <div class="brand-header">
            <img src="images/St_logo_dark.png" alt="Stan's Technologies" style="width: 120px; height: auto;">
            <div>
            <h1 style="margin: 0;">StanLogic - KMapSolver (Viz)</h1>
            <p class="subtitle" style="margin: 5px 0 0 0;">
                Visualization of our Clustering-Coordinate Based Algorithm for solving Karnaugh Maps
            </p>
            </div>
        </div>

        <div class="info-box">
            <strong>Instructions:</strong> Click cells to cycle through values (0 ‚Üí 1 ‚Üí Don't Care ‚Üí 0). 
            Select your K-map size, minimization form, and convention, then click "Solve & Visualize" to see the algorithm in action!
        </div>

        <div class="controls">
            <div class="control-group">
                <label>K-Map Size:</label>
                <div class="btn-group">
                    <button class="btn-secondary size-btn active" data-size="2">2√ó2 (2 vars)</button>
                    <button class="btn-secondary size-btn" data-size="3">2√ó4 (3 vars)</button>
                    <button class="btn-secondary size-btn" data-size="4">4√ó4 (4 vars)</button>
                    <button class="btn-secondary size-btn" data-size="5">5 vars (3D)</button>
                    <button class="btn-secondary size-btn" data-size="6">6 vars (3D)</button>
                    <button class="btn-secondary size-btn" data-size="7">7 vars (3D)</button>
                    <button class="btn-secondary size-btn" data-size="8">8 vars (3D)</button>
                </div>
            </div>

            <div class="control-group">
                <label>Minimization Form:</label>
                <div class="btn-group">
                    <button class="btn-secondary form-btn active" data-form="sop">SOP (Sum of Products)</button>
                    <button class="btn-secondary form-btn" data-form="pos">POS (Product of Sums)</button>
                </div>
            </div>

            <div class="control-group">
                <label>Variable Convention:</label>
                <div class="btn-group">
                    <button class="btn-secondary conv-btn active" data-conv="vranesic">Vranesic (cols=x1x2)</button>
                    <button class="btn-secondary conv-btn" data-conv="mano_kime">Mano-Kime (rows=x1x2)</button>
                </div>
            </div>

            <div class="control-group">
                <label>Actions:</label>
                <div class="btn-group">
                    <button class="btn-success" id="solveBtn">üöÄ Solve & Visualize</button>
                    <button class="btn-secondary" id="clearBtn">üîÑ Clear All</button>
                    <button class="btn-secondary" id="randomBtn">üé≤ Random Fill</button>
                </div>
            </div>
        </div>

        <div class="kmap-container">
            <div id="kmapDisplay"></div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-box" style="border-color: #f05545;"></div>
                <span style="color: #f05545;">0 (False)</span>
            </div>
            <div class="legend-item">
                <div class="legend-box" style="border-color: #7ee787;"></div>
                <span style="color: #7ee787;">1 (True)</span>
            </div>
            <div class="legend-item">
                <div class="legend-box" style="border-color: #ffc93c;"></div>
                <span style="color: #ffc93c;">d (Don't Care)</span>
            </div>
        </div>

        <div id="visualizationArea"></div>

        <footer class="footer">
            <div>Stan‚Äôs Technologies ‚Ä¢ Efficient logic. Practical systems.</div>
            <div class="footer-links">
                <a href="mailto:stanstechnologies@gmail.com">stanstechnologies@gmail.com</a>
                <a href="https://www.linkedin.com/company/stan-s-technologies" target="_blank" rel="noopener noreferrer">
                    <img src="https://img.freepik.com/premium-vector/square-linkedin-logo-isolated-white-background_469489-892.jpg?semt=ais_hybrid&w=740&q=80" alt="LinkedIn">
                    <span>LinkedIn</span>
                </a>
            </div>
        </footer>
    </div>

    <script>
        // State management
        let state = {
            size: 2,
            form: 'sop',
            convention: 'vranesic',
            kmap: [[0, 0], [0, 0]],
            is3D: false,
            numExtraVars: 0,
            kmaps3D: {} // For 3D: key = extra_var_combo, value = 4x4 array
        };

        // Initialize K-map display
        function initKMap() {
            const sizes = {
                2: { rows: 2, cols: 2, rowLabels: ['0', '1'], colLabels: ['0', '1'] },
                3: { rows: 2, cols: 4, rowLabels: ['0', '1'], colLabels: ['00', '01', '11', '10'] },
                4: { rows: 4, cols: 4, rowLabels: ['00', '01', '11', '10'], colLabels: ['00', '01', '11', '10'] }
            };

            // Check if 3D mode (5+ variables)
            state.is3D = state.size >= 5;
            
            if (state.is3D) {
                init3DKMap();
                return;
            }

            const config = sizes[state.size];
            state.kmap = Array(config.rows).fill(0).map(() => Array(config.cols).fill(0));

            const container = document.getElementById('kmapDisplay');
            let html = '<div class="kmap-wrapper">';
            
            // Column labels
            html += '<div class="kmap-labels">';
            config.colLabels.forEach(label => {
                html += `<div class="kmap-label">${label}</div>`;
            });
            html += '</div>';

            // Rows with labels
            for (let i = 0; i < config.rows; i++) {
                html += '<div class="kmap-row">';
                html += `<div class="row-label">${config.rowLabels[i]}</div>`;
                for (let j = 0; j < config.cols; j++) {
                    html += `<div class="kmap-cell" data-row="${i}" data-col="${j}">0</div>`;
                }
                html += '</div>';
            }
            html += '</div>';
            container.innerHTML = html;

            // Add click handlers
            document.querySelectorAll('.kmap-cell').forEach(cell => {
                cell.addEventListener('click', toggleCell);
            });
        }

        // Initialize 3D K-map display (5+ variables)
        function init3DKMap() {
            state.numExtraVars = state.size - 4;
            const numMaps = Math.pow(2, state.numExtraVars);
            state.kmaps3D = {};
            
            // Generate all combinations for extra variables
            for (let i = 0; i < numMaps; i++) {
                const extraCombo = i.toString(2).padStart(state.numExtraVars, '0');
                state.kmaps3D[extraCombo] = Array(4).fill(0).map(() => Array(4).fill(0));
            }

            const container = document.getElementById('kmapDisplay');
            let html = '<div style="max-height: 600px; overflow-x: auto; overflow-y: auto; padding: 10px;">';
            html += `<h3 style="color: #e9eef8; text-align: center; margin-bottom: 20px;">${state.size}-Variable 3D K-Map (${numMaps} sub-maps)</h3>`;
            html += '<div style="display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; align-items: flex-start;">';
            
            const colLabels = ['00', '01', '11', '10'];
            const rowLabels = ['00', '01', '11', '10'];
            
            // Create each 4x4 sub-map
            for (let i = 0; i < numMaps; i++) {
                const extraCombo = i.toString(2).padStart(state.numExtraVars, '0');
                const extraVarLabels = [];
                for (let v = 0; v < state.numExtraVars; v++) {
                    extraVarLabels.push(`x${v+1}=${extraCombo[v]}`);
                }
                
                html += `<div style="background: rgba(11, 24, 50, 0.5); padding: 15px; border-radius: 8px; border: 1px solid #1b2f55; flex: 0 0 auto;">`;
                html += `<div style="color: #a8b3c7; font-weight: 600; margin-bottom: 10px; text-align: center;">${extraVarLabels.join(', ')}</div>`;
                html += '<div class="kmap-wrapper" style="display: inline-block;">';
                
                // Column labels
                html += '<div class="kmap-labels">';
                colLabels.forEach(label => {
                    html += `<div class="kmap-label">${label}</div>`;
                });
                html += '</div>';

                // Rows
                for (let r = 0; r < 4; r++) {
                    html += '<div class="kmap-row">';
                    html += `<div class="row-label">${rowLabels[r]}</div>`;
                    for (let c = 0; c < 4; c++) {
                        html += `<div class="kmap-cell" data-extra="${extraCombo}" data-row="${r}" data-col="${c}">0</div>`;
                    }
                    html += '</div>';
                }
                html += '</div></div>';
            }
            
            html += '</div></div>'; // Close flexbox container and main wrapper
            container.innerHTML = html;

            // Add click handlers
            document.querySelectorAll('.kmap-cell').forEach(cell => {
                cell.addEventListener('click', toggleCell3D);
            });
        }

        function toggleCell(e) {
            const row = parseInt(e.target.dataset.row);
            const col = parseInt(e.target.dataset.col);
            const current = state.kmap[row][col];
            
            // Cycle: 0 -> 1 -> 'd' -> 0
            let next;
            if (current === 0) next = 1;
            else if (current === 1) next = 'd';
            else next = 0;
            
            state.kmap[row][col] = next;
            updateCell(e.target, next);
        }

        function toggleCell3D(e) {
            const extra = e.target.dataset.extra;
            const row = parseInt(e.target.dataset.row);
            const col = parseInt(e.target.dataset.col);
            const current = state.kmaps3D[extra][row][col];
            
            // Cycle: 0 -> 1 -> 'd' -> 0
            let next;
            if (current === 0) next = 1;
            else if (current === 1) next = 'd';
            else next = 0;
            
            state.kmaps3D[extra][row][col] = next;
            updateCell(e.target, next);
        }

        function updateCell(cell, value) {
            cell.textContent = value;
            cell.className = 'kmap-cell';
            if (value === 1) cell.classList.add('one');
            else if (value === 0) cell.classList.add('zero');
            else if (value === 'd') cell.classList.add('dontcare');
            else cell.classList.add('zero'); // Default to zero style if something is wrong
        }

        // Button handlers
        document.querySelectorAll('.size-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                state.size = parseInt(e.target.dataset.size);
                initKMap();
                clearVisualization();
            });
        });

        document.querySelectorAll('.form-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.form-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                state.form = e.target.dataset.form;
                clearVisualization();
            });
        });

        document.querySelectorAll('.conv-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.conv-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                state.convention = e.target.dataset.conv;
                clearVisualization();
            });
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            if (state.is3D) {
                Object.keys(state.kmaps3D).forEach(extra => {
                    state.kmaps3D[extra] = Array(4).fill(0).map(() => Array(4).fill(0));
                });
            } else {
                state.kmap = state.kmap.map(row => row.map(() => 0));
            }
            document.querySelectorAll('.kmap-cell').forEach(cell => {
                updateCell(cell, 0);
            });
            clearVisualization();
        });

        document.getElementById('randomBtn').addEventListener('click', () => {
            if (state.is3D) {
                Object.keys(state.kmaps3D).forEach(extra => {
                    state.kmaps3D[extra] = Array(4).fill(0).map(() => 
                        Array(4).fill(0).map(() => {
                            const rand = Math.random();
                            if (rand < 0.4) return 0;
                            if (rand < 0.8) return 1;
                            return 'd';
                        })
                    );
                });
                document.querySelectorAll('.kmap-cell').forEach(cell => {
                    const extra = cell.dataset.extra;
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    updateCell(cell, state.kmaps3D[extra][row][col]);
                });
            } else {
                state.kmap = state.kmap.map(row => 
                    row.map(() => {
                        const rand = Math.random();
                        if (rand < 0.4) return 0;
                        if (rand < 0.8) return 1;
                        return 'd';
                    })
                );
                document.querySelectorAll('.kmap-cell').forEach((cell, idx) => {
                    const cols = state.kmap[0].length;
                    const row = Math.floor(idx / cols);
                    const col = idx % cols;
                    updateCell(cell, state.kmap[row][col]);
                });
            }
            clearVisualization();
        });

        function clearVisualization() {
            document.getElementById('visualizationArea').innerHTML = '';
        }

        // Simplified 3D visualization (5+ variables)
        function render3DVisualization(result, viz) {
            const numVars = result.num_vars;
            const numExtraVars = numVars - 4;
            const numMaps = Math.pow(2, numExtraVars);
            const numTerms = result.steps.finalSelected.terms.length;
            
            viz.querySelector('.visualization').innerHTML += `
                <div class="step-container">
                    <div class="step-title">üéØ 3D K-Map Solution (${numVars} Variables)</div>
                    <div class="step-content">
                        <div class="result">${result.expression || '0'}</div>
                        <p style="margin-top: 15px;"><strong>Solution:</strong> ${numTerms} term(s)</p>
                    </div>
                </div>
            `;
            
            // Step 1: Architecture Overview
            const step1 = document.createElement('div');
            step1.className = 'step-container';
            step1.innerHTML = `
                <div class="step-title">
                    <span>Step 1: 3D K-Map Architecture</span>
                </div>
                <div class="step-content">
                    <p><strong>Hierarchical Structure:</strong></p>
                    <div style="background: rgba(11, 24, 50, 0.7); padding: 20px; border-radius: 10px; margin: 15px 0;">
                        <div style="font-size: 1.2em; margin-bottom: 15px;">
                            üìä <strong>${numVars} variables</strong> = <strong>${numExtraVars} extra vars</strong> + <strong>4 base vars</strong>
                        </div>
                        <div style="font-size: 1.1em; margin-bottom: 10px;">
                            üóÇÔ∏è <strong>${numMaps} hierarchical 4√ó4 K-maps</strong> created
                        </div>
                        <div style="font-size: 0.95em; color: #a8b3c7;">
                            Each map handles one combination of the first ${numExtraVars} variable(s)
                        </div>
                    </div>
                    <p><strong>Algorithm:</strong> Each 4√ó4 map is solved independently using our clustering algorithm, then results are combined using bitwise union operations.</p>
                </div>
            `;
            viz.querySelector('.visualization').appendChild(step1);
            
            // Step 2: Individual Map Solving (animated)
            const step2 = document.createElement('div');
            step2.className = 'step-container';
            step2.innerHTML = `
                <div class="step-title">
                    <span>Step 2: Solving Each Sub-Map</span>
                    <button class="btn-replay">üîÑ Replay</button>
                </div>
                <div class="step-content">
                    <p><strong>Process:</strong> Apply clustering algorithm to each of the ${numMaps} sub-maps</p>
                    <div id="map-solving-animation" style="background: rgba(11, 24, 50, 0.7); padding: 30px; border-radius: 10px; margin: 15px 0; text-align: center;">
                        <div style="font-size: 3em; margin-bottom: 10px;">üó∫Ô∏è</div>
                        <div id="solving-status" style="font-size: 1.2em; color: #7ee787; margin-bottom: 15px;">
                            Ready to solve ${numMaps} maps...
                        </div>
                        <div id="progress-bar" style="width: 100%; height: 8px; background: #1b2f55; border-radius: 4px; overflow: hidden;">
                            <div id="progress-fill" style="width: 0%; height: 100%; background: linear-gradient(90deg, #4ea1ff, #7ee787); transition: width 0.3s ease;"></div>
                        </div>
                        <div id="map-counter" style="margin-top: 10px; color: #a8b3c7; font-size: 0.9em;">
                            0 / ${numMaps} maps solved
                        </div>
                    </div>
                    <p style="color: #a8b3c7; font-size: 0.9em;"><em>Each sub-map: Find groups ‚Üí Filter primes ‚Üí Essential detection ‚Üí Greedy cover</em></p>
                </div>
            `;
            viz.querySelector('.visualization').appendChild(step2);
            
            const animateMapSolving = async () => {
                const status = step2.querySelector('#solving-status');
                const progressFill = step2.querySelector('#progress-fill');
                const counter = step2.querySelector('#map-counter');
                
                progressFill.style.width = '0%';
                status.textContent = 'Solving maps...';
                counter.textContent = `0 / ${numMaps} maps solved`;
                
                for (let i = 0; i < numMaps; i++) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                    const progress = ((i + 1) / numMaps) * 100;
                    progressFill.style.width = progress + '%';
                    counter.textContent = `${i + 1} / ${numMaps} maps solved`;
                    
                    if (i === numMaps - 1) {
                        status.textContent = '‚úÖ All maps solved!';
                        status.style.color = '#7ee787';
                    }
                }
            };
            
            animateMapSolving();
            step2.querySelector('.btn-replay').addEventListener('click', animateMapSolving);
            
            // Step 3: Pattern Grouping (animated)
            const step3 = document.createElement('div');
            step3.className = 'step-container';
            step3.innerHTML = `
                <div class="step-title">
                    <span>Step 3: Bitwise Union - Pattern Grouping</span>
                    <button class="btn-replay">üîÑ Replay</button>
                </div>
                <div class="step-content">
                    <p><strong>Combining Results:</strong> Group terms with identical 4-bit patterns across different maps</p>
                    <div id="union-animation" style="background: rgba(11, 24, 50, 0.7); padding: 30px; border-radius: 10px; margin: 15px 0;">
                        <div style="display: flex; justify-content: space-around; align-items: center; margin-bottom: 20px;">
                            <div class="pattern-box" style="background: #1b2f55; padding: 15px; border-radius: 8px; border: 2px solid #4ea1ff;">
                                <div style="font-size: 0.9em; color: #a8b3c7; margin-bottom: 5px;">Pattern A</div>
                                <div style="font-family: monospace; color: #4ea1ff;">01--</div>
                                <div style="font-size: 0.8em; color: #7ee787; margin-top: 5px;" id="pattern-a-maps">Maps: 0,1,2</div>
                            </div>
                            <div style="font-size: 2em; color: #c19a6b;">‚äï</div>
                            <div class="pattern-box" style="background: #1b2f55; padding: 15px; border-radius: 8px; border: 2px solid #4ea1ff;">
                                <div style="font-size: 0.9em; color: #a8b3c7; margin-bottom: 5px;">Pattern B</div>
                                <div style="font-family: monospace; color: #4ea1ff;">-101</div>
                                <div style="font-size: 0.8em; color: #7ee787; margin-top: 5px;" id="pattern-b-maps">Maps: 0,3</div>
                            </div>
                        </div>
                        <div style="text-align: center; color: #e9eef8; font-size: 1.1em; margin-top: 20px;">
                            ‚Üì Simplify Extra Variables ‚Üì
                        </div>
                        <div id="simplified-result" style="background: #2d3e50; padding: 15px; border-radius: 8px; margin-top: 15px; text-align: center; opacity: 0; transition: opacity 0.5s;">
                            <div style="color: #7ee787; font-size: 1.1em;">Combined Terms Ready</div>
                        </div>
                    </div>
                    <p><strong>Key Concept:</strong> When a pattern appears across multiple maps, we simplify the extra variable portion by finding which bits vary (set to '-') vs. stay constant.</p>
                </div>
            `;
            viz.querySelector('.visualization').appendChild(step3);
            
            const animateUnion = async () => {
                const result = step3.querySelector('#simplified-result');
                result.style.opacity = '0';
                
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Animate pattern boxes
                const boxes = step3.querySelectorAll('.pattern-box');
                boxes.forEach((box, i) => {
                    setTimeout(() => {
                        box.style.transform = 'scale(1.05)';
                        box.style.borderColor = '#7ee787';
                        setTimeout(() => {
                            box.style.transform = 'scale(1)';
                        }, 300);
                    }, i * 400);
                });
                
                await new Promise(resolve => setTimeout(resolve, 1200));
                result.style.opacity = '1';
            };
            
            animateUnion();
            step3.querySelector('.btn-replay').addEventListener('click', animateUnion);
            
            // Step 4: Final Expression
            const step4 = document.createElement('div');
            step4.className = 'step-container';
            step4.innerHTML = `
                <div class="step-title">‚ú® Final Minimized Expression</div>
                <div class="step-content">
                    <p><strong>Result:</strong> Combined and simplified all patterns</p>
                    <div class="result">${result.expression || '0'}</div>
                    <br>
                    <p><strong>Final solution uses ${numTerms} term(s):</strong></p>
                    <div class="group-list">
                        ${result.steps.finalSelected.terms.map(term =>
                            `<div class="group-item essential">${term}</div>`).join('')}
                    </div>
                    <div style="background: rgba(126, 231, 135, 0.1); border-left: 4px solid #7ee787; padding: 15px; margin-top: 20px; border-radius: 5px;">
                        <p style="margin: 0;"><strong>Algorithm Complexity Summary:</strong></p>
                        <ul style="margin: 10px 0 0 20px; padding: 0; color: #a8b3c7;">
                            <li>Sub-map solving: O(${numMaps} √ó standard K-map complexity)</li>
                            <li>Pattern grouping: O(total terms √ó pattern length)</li>
                            <li>Variable simplification: O(terms per pattern √ó ${numExtraVars})</li>
                        </ul>
                    </div>
                </div>
            `;
            viz.querySelector('.visualization').appendChild(step4);
        }

        // Simplified KMapSolver class - ONLY for visualization
        class KMapSolver {
            constructor(kmap, convention = 'vranesic', stepContainer = null) {
                this.kmap = kmap;
                this.numRows = kmap.length;
                this.numCols = kmap[0].length;
                this.convention = convention.toLowerCase();
                this.stepContainer = stepContainer; // Store reference to current step
                
                const size = this.numRows * this.numCols;
                if (size === 4) {
                    this.numVars = 2;
                    this.rowLabels = ['0', '1'];
                    this.colLabels = ['0', '1'];
                } else if (size === 8) {
                    this.numVars = 3;
                    this.rowLabels = ['0', '1'];
                    this.colLabels = ['00', '01', '11', '10'];
                } else if (size === 16) {
                    this.numVars = 4;
                    this.rowLabels = ['00', '01', '11', '10'];
                    this.colLabels = ['00', '01', '11', '10'];
                }
                
                this.buildLookupTables();
            }

            buildLookupTables() {
                this.cellIndex = [];
                this.cellBits = [];
                this.indexToRC = {};
                
                for (let r = 0; r < this.numRows; r++) {
                    this.cellIndex[r] = [];
                    this.cellBits[r] = [];
                    for (let c = 0; c < this.numCols; c++) {
                        const bits = this.convention === 'mano_kime' 
                            ? this.rowLabels[r] + this.colLabels[c]
                            : this.colLabels[c] + this.rowLabels[r];
                        const index = parseInt(bits, 2);
                        this.cellIndex[r][c] = index;
                        this.cellBits[r][c] = bits;
                        this.indexToRC[index] = [r, c];
                    }
                }
            }

            createAnimatedKmap() {
                const sizes = {
                    2: { rows: 2, cols: 2, rowLabels: ['0', '1'], colLabels: ['0', '1'] },
                    3: { rows: 2, cols: 4, rowLabels: ['0', '1'], colLabels: ['00', '01', '11', '10'] },
                    4: { rows: 4, cols: 4, rowLabels: ['00', '01', '11', '10'], colLabels: ['00', '01', '11', '10'] }
                };

                const config = sizes[this.numRows * this.numCols === 4 ? 2 : this.numRows * this.numCols === 8 ? 3 : 4];
                
                let html = '<div class="animated-kmap"><div class="kmap-wrapper">';
                
                // Add SVG overlay for cluster rectangles
                html += '<svg class="cluster-overlay"></svg>';
                
                html += '<div class="kmap-labels">';
                config.colLabels.forEach(label => {
                    html += `<div class="kmap-label">${label}</div>`;
                });
                html += '</div>';

                for (let i = 0; i < config.rows; i++) {
                    html += '<div class="kmap-row">';
                    html += `<div class="row-label">${config.rowLabels[i]}</div>`;
                    for (let j = 0; j < config.cols; j++) {
                        const val = this.kmap[i][j];
                        let cellClass = 'kmap-cell';
                        if (val === 1) cellClass += ' one';
                        else if (val === 0) cellClass += ' zero';
                        else if (val === 'd') cellClass += ' dontcare';
                        html += `<div class="${cellClass}" data-row="${i}" data-col="${j}">${val}</div>`;
                    }
                    html += '</div>';
                }
                html += '</div></div>';
                
                return html;
            }

            // Utility: convert mask to coordinate array
            maskToCoords(mask) {
                const coords = [];
                let temp = mask;
                while (temp) {
                    const low = temp & -temp;
                    const idx = Math.log2(low);
                    temp -= low;
                    if (this.indexToRC[idx]) coords.push(this.indexToRC[idx]);
                }
                return coords;
            }

            // REPLACE previous drawClusterFromCoords implementation
            drawClusterFromCoords(coords, colorClass = 'group-color') {
                if (!coords || coords.length === 0) return;

                const container = this.stepContainer?.querySelector('.animated-kmap')
                    || document.querySelector('.step-container:last-child .animated-kmap');
                if (!container) return;

                const svg = container.querySelector('.cluster-overlay');
                const firstCell = container.querySelector('.kmap-cell');
                if (!svg || !firstCell) return;

                const gap = 5;
                const extend = 8; // extra extension for toroidal sides
                const cellWidth = firstCell.offsetWidth;
                const cellHeight = firstCell.offsetHeight;

                const rowLabel = container.querySelector('.row-label');
                const colLabelRow = container.querySelector('.kmap-labels');
                const offsetX = (rowLabel ? rowLabel.offsetWidth : 45) + gap;
                const offsetY = (colLabelRow ? colLabelRow.offsetHeight : cellHeight) + gap;

                const rows = [...new Set(coords.map(c => c[0]))].sort((a,b)=>a-b);
                const cols = [...new Set(coords.map(c => c[1]))].sort((a,b)=>a-b);

                const rowSpan = rows[rows.length-1] - rows[0] + 1;
                const colSpan = cols[cols.length-1] - cols[0] + 1;

                const wrapRow = rows.length > 1 && rowSpan !== rows.length;
                const wrapCol = cols.length > 1 && colSpan !== cols.length;

                const buildSegments = values => {
                    if (!values.length) return [];
                    if (values[values.length-1] - values[0] + 1 === values.length) {
                        return [[values[0], values[values.length-1]]];
                    }
                    for (let i=1;i<values.length;i++){
                        if (values[i] !== values[i-1] + 1) {
                            const head = values.slice(i);
                            const tail = values.slice(0,i);
                            return [[head[0], head[head.length-1]],[tail[0], tail[tail.length-1]]];
                        }
                    }
                    return [[values[0], values[values.length-1]]];
                };

                const rowSegments = wrapRow ? buildSegments(rows) : [[rows[0], rows[rows.length-1]]];
                const colSegments = wrapCol ? buildSegments(cols) : [[cols[0], cols[cols.length-1]]];

                // Helper to draw a covering "eraser" line to hide an outside border
                const coverLine = (x1,y1,x2,y2,isVertical) => {
                    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
                    line.setAttribute('x1', x1);
                    line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2);
                    line.setAttribute('y2', y2);
                    line.setAttribute('stroke', '#0b1832'); /* CHANGED from #fff to match step background */
                    line.setAttribute('stroke-width', isVertical ? 6 : 6);
                    line.setAttribute('stroke-linecap','butt');
                    svg.appendChild(line);
                };

                rowSegments.forEach(([rStart,rEnd]) => {
                    colSegments.forEach(([cStart,cEnd]) => {

                        let rectX = offsetX + cStart * (cellWidth + gap);
                        let rectY = offsetY + rStart * (cellHeight + gap);
                        let rectW = (cEnd - cStart + 1) * (cellWidth + gap) - gap;
                        let rectH = (rEnd - rStart + 1) * (cellHeight + gap) - gap;

                        const outsideLeft  = wrapCol && cStart === 0;
                        const outsideRight = wrapCol && cEnd === this.numCols - 1;
                        const outsideTop    = wrapRow && rStart === 0;
                        const outsideBottom = wrapRow && rEnd === this.numRows - 1;

                        // Extend on wrapped outer sides
                        if (outsideLeft) {
                            rectX -= extend;
                            rectW += extend;
                        }
                        if (outsideRight) {
                            rectW += extend;
                        }
                        if (outsideTop) {
                            rectY -= extend;
                            rectH += extend;
                        }
                        if (outsideBottom) {
                            rectH += extend;
                        }

                        // Draw rectangle
                        const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
                        rect.setAttribute('x', rectX);
                        rect.setAttribute('y', rectY);
                        rect.setAttribute('width', rectW);
                        rect.setAttribute('height', rectH);
                        rect.setAttribute('class', `cluster-rect ${colorClass} ${wrapRow || wrapCol ? 'wrap' : ''}`);
                        svg.appendChild(rect);

                        // Cover outside borders to "hide" them visually (toroidal open bracket)
                        // Vertical sides
                        if (outsideLeft) {
                            const xHide = rectX;
                            coverLine(xHide, rectY, xHide, rectY + rectH, true);
                        }
                        if (outsideRight) {
                            const xHide = rectX + rectW;
                            coverLine(xHide, rectY, xHide, rectY + rectH, true);
                        }
                        // Horizontal sides
                        if (outsideTop) {
                            const yHide = rectY;
                            coverLine(rectX, yHide, rectX + rectW, yHide, false);
                        }
                        if (outsideBottom) {
                            const yHide = rectY + rectH;
                            coverLine(rectX, yHide, rectX + rectW, yHide, false);
                        }
                    });
                });
            }

            // Route mask drawing through coords
            drawClusterRect(mask, colorClass='group-color') {
                const coords = this.maskToCoords(mask);
                this.drawClusterFromCoords(coords, colorClass);
            }

            async animateLabel(text) {
                const container = this.stepContainer || document.querySelector('.step-container:last-child .step-content');
                const existing = container.querySelector('.animation-label');
                if (existing) existing.remove();
                
                const label = document.createElement('div');
                label.className = 'animation-label';
                label.textContent = text;
                container.querySelector('.animated-kmap')?.before(label);
                
                await this.delay(300);
            }

            clearAnimations() {
                const container = this.stepContainer || document.querySelector('.step-container:last-child .animated-kmap');
                if (container) {
                    const svg = container.querySelector('.cluster-overlay');
                    if (svg) {
                        svg.innerHTML = '';
                    }
                }
            }

            // ADDED: remove any persistent coverage badges inside this step's animated K-map
            clearCoverageBadges() {
                const container = this.stepContainer?.querySelector('.animated-kmap');
                if (!container) return;
                container.querySelectorAll('.cell-badges').forEach(el => el.remove());
            }

            // ADDED: render persistent coverage incidence badges (Pk) in each covered cell
            // primeCoordsList: Array<Array<[r,c]>>; primeTerms: Array<string> (optional)
            renderCoverageIncidence(primeCoordsList, primeTerms = []) {
                const container = this.stepContainer?.querySelector('.animated-kmap');
                if (!container || !Array.isArray(primeCoordsList)) return;

                // Build per-cell coverage list of prime indices
                const coverMap = new Map();
                primeCoordsList.forEach((coords, pIdx) => {
                    (coords || []).forEach(([r, c]) => {
                        const key = `${r},${c}`;
                        if (!coverMap.has(key)) coverMap.set(key, []);
                        coverMap.get(key).push(pIdx);
                    });
                });

                // Render badges for each covered cell
                coverMap.forEach((primeIdxList, key) => {
                    const [r, c] = key.split(',').map(Number);
                    const cell = container.querySelector(`.kmap-cell[data-row="${r}"][data-col="${c}"]`);
                    if (!cell) return;

                    // Ensure clean slate
                    cell.querySelectorAll('.cell-badges').forEach(el => el.remove());

                    const badgeWrap = document.createElement('div');
                    badgeWrap.className = 'cell-badges';

                    primeIdxList.sort((a, b) => a - b).forEach(p => {
                        const span = document.createElement('span');
                        span.className = 'prime-badge';
                        span.textContent = `P${p + 1}`;
                        span.title = primeTerms?.[p] ? `P${p + 1}: ${primeTerms[p]}` : `Prime ${p + 1}`;
                        badgeWrap.appendChild(span);
                    });

                    cell.appendChild(badgeWrap);
                });
            }

            showStaticClusters(clusters) {
                const container = document.querySelector('.step-container:last-child .animated-kmap');
                if (!container) return;
                
                for (const mask of clusters) {
                    this.drawClusterRect(mask, 'group-color');
                }
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            highlightGroup(mask) {
                this.clearHighlights();
                let temp = mask;
                while (temp) {
                    const low = temp & -temp;
                    const idx = Math.log2(low);
                    temp -= low;
                    const [r, c] = this.indexToRC[idx];
                    const cells = document.querySelectorAll('#kmapDisplay .kmap-cell');
                    const cellIdx = r * this.numCols + c;
                    if (cells[cellIdx]) cells[cellIdx].classList.add('grouped');
                }
            }

            clearHighlights() {
                document.querySelectorAll('#kmapDisplay .kmap-cell').forEach(cell => {
                    cell.classList.remove('grouped');
                });
            }

            countBits(n) {
                let count = 0;
                while (n) {
                    count += n & 1;
                    n >>= 1;
                }
                return count;
            }

            maskToTerm(mask, targetVal) {
                const bitsList = [];
                let temp = mask;
                while (temp) {
                    const low = temp & -temp;
                    const idx = Math.log2(low);
                    temp -= low;
                    const [r, c] = this.indexToRC[idx];
                    bitsList.push(this.cellBits[r][c]);
                }

                const bits = bitsList[0].split('');
                for (let i = 1; i < bitsList.length; i++) {
                    for (let j = 0; j < this.numVars; j++) {
                        if (bits[j] !== bitsList[i][j]) bits[j] = '-';
                    }
                }

                const vars = Array.from({length: this.numVars}, (_, i) => `x${i+1}`);
                const literals = [];
                
                if (targetVal === 0) {
                    for (let i = 0; i < bits.length; i++) {
                        if (bits[i] === '1') literals.push(vars[i] + "'");
                        else if (bits[i] === '0') literals.push(vars[i]);
                    }
                    return literals.length ? '(' + literals.join(' + ') + ')' : '1';
                } else {
                    for (let i = 0; i < bits.length; i++) {
                        if (bits[i] === '0') literals.push(vars[i] + "'");
                        else if (bits[i] === '1') literals.push(vars[i]);
                    }
                    return literals.length ? literals.join('') : '1';
                }
            }
        }

        // Core solver logic - USING PYTHON BACKEND
        document.getElementById('solveBtn').addEventListener('click', async () => {
            const viz = document.getElementById('visualizationArea');
            viz.innerHTML = '<div class="visualization"><h2 style="color: #1a2942; margin-bottom: 20px;">üîç Algorithm Visualization</h2><p class="subtitle">Connecting to Python backend...</p></div>';
            
            try {
                // Prepare data based on 2D or 3D mode
                const requestData = {
                    form: state.form,
                    convention: state.convention
                };
                
                if (state.is3D) {
                    // Convert 3D kmaps to flat output_values array
                    const numVars = state.size;
                    const totalCells = Math.pow(2, numVars);
                    const output_values = new Array(totalCells);
                    
                    // Build index mapping based on convention
                    Object.keys(state.kmaps3D).forEach(extra => {
                        const kmap4x4 = state.kmaps3D[extra];
                        for (let r = 0; r < 4; r++) {
                            for (let c = 0; c < 4; c++) {
                                const rowBits = ['00', '01', '11', '10'][r];
                                const colBits = ['00', '01', '11', '10'][c];
                                const bits = state.convention === 'mano_kime'
                                    ? extra + rowBits + colBits
                                    : extra + colBits + rowBits;
                                const index = parseInt(bits, 2);
                                output_values[index] = kmap4x4[r][c];
                            }
                        }
                    });
                    
                    requestData.num_vars = numVars;
                    requestData.output_values = output_values;
                    requestData.is3D = true;
                } else {
                    requestData.kmap = state.kmap;
                    requestData.is3D = false;
                }
                
                const response = await fetch('http://localhost:5000/api/solve', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(requestData)
                });
                
                if (!response.ok) {
                    throw new Error('Failed to connect to Python backend. Ensure Flask server is running: python app.py');
                }
                
                const result = await response.json();
                if (!result.success) throw new Error(result.error);
                
                const targetVal = result.targetValue;
                const targetName = targetVal === 0 ? "0's" : "1's";
                
                viz.innerHTML = `<div class="visualization"><h2 style="color: #e9eef8; margin-bottom: 20px;">üîç Algorithm Visualization (Python Backend)</h2></div>`;
                
                // Check if 3D mode
                if (result.is3D) {
                    // Simplified 3D visualization
                    render3DVisualization(result, viz);
                    return;
                }
                
                // STEP 0: Show final result first
                viz.querySelector('.visualization').innerHTML += `
                    <div class="step-container">
                        <div class="step-title">‚úÖ Final Solution from Python (stanlogic)</div>
                        <div class="step-content">
                            <div class="result">${result.expression}</div>
                            <strong>Minimized to ${result.steps.finalSelected.terms.length} term(s)</strong>
                        </div>
                    </div>
                `;

                // STEP 1: All groups found
                const step1 = document.createElement('div');
                step1.className = 'step-container';
                step1.innerHTML = `
                    <div class="step-title">
                        <span>Step 1: Finding All Valid Groups of ${targetName}</span>
                        <button class="btn-replay">üîÑ Replay</button>
                    </div>
                    <div class="step-content">
                        <p><strong>What happens here?</strong> We systematically enumerate every rectangular, power-of-two sized cluster (including wrap-around/toroidal cases). Each cluster becomes a bitmask: a single integer whose set bits mark the covered cells. Only cells with ${targetName} and optional don't cares enter these masks, guaranteeing semantic correctness.</p>
                        <p><strong>Why bitmasks?</strong> They allow constant-time subset checks, unions, and popcounts using native CPU operations.</p>
                        <p><strong>Complexity:</strong> O(n ¬∑ |G| ¬∑ s) where n = cells (4/8/16), |G| ‚â§ 9 possible dimensions, s = average group size. For 4√ó4 maps this remains very small.</p>
                        <p>Found <strong>${result.steps.allGroups.count}</strong> valid rectangular groups.</p>
                        <p><em>Each group contains ONLY ${targetName} (and optionally don't cares)</em></p>
                    </div>
                `;
                viz.querySelector('.visualization').appendChild(step1);
                
                // Create solver instance for this specific step
                const solver1 = new KMapSolver(state.kmap, state.convention, step1);
                step1.querySelector('.step-content').insertAdjacentHTML('afterbegin', solver1.createAnimatedKmap());
                
                const animateStep1 = async () => {
                    solver1.clearAnimations();
                    for (let i = 0; i < result.steps.allGroups.coords.length; i++) {
                        await solver1.animateLabel(`Group ${i + 1}...`);
                        solver1.drawClusterFromCoords(result.steps.allGroups.coords[i], 'group-color');
                        await solver1.delay(400);
                        solver1.clearAnimations();
                    }
                    await solver1.animateLabel('All Found Groups');
                    for (const coords of result.steps.allGroups.coords) {
                        solver1.drawClusterFromCoords(coords, 'group-color');
                    }
                };
                
                await animateStep1();
                step1.querySelector('.btn-replay').addEventListener('click', animateStep1);

                // STEP 2: Prime implicants
                const step2 = document.createElement('div');
                step2.className = 'step-container';
                step2.innerHTML = `
                    <div class="step-title">
                        <span>Step 2: Filtering Prime Implicants</span>
                        <button class="btn-replay">üîÑ Replay</button>
                    </div>
                    <div class="step-content">
                        <p><strong>What happens?</strong> We remove any group fully covered by a larger group. Using bitmasks, a subset test is simply (g & h) == g. Survivors are maximal rectangles ‚Üí prime implicants.</p>
                        <p><strong>Complexity:</strong> O(|G|¬≤) worst-case (|G| groups before pruning). Very manageable for ‚â§16 cells.</p>
                        <p>Removed ${result.steps.allGroups.count - result.steps.primeImplicants.count} redundant groups. <strong>${result.steps.primeImplicants.count}</strong> prime implicants remain:</p>
                        <div class="group-list">
                            ${result.steps.primeImplicants.terms.map((term, i) =>
                                `<div class="group-item">Prime ${i+1}: ${term}</div>`).join('')}
                        </div>
                    </div>
                `;
                viz.querySelector('.visualization').appendChild(step2);
                
                const solver2 = new KMapSolver(state.kmap, state.convention, step2);
                step2.querySelector('.step-content').insertAdjacentHTML('afterbegin', solver2.createAnimatedKmap());
                
                const animateStep2 = async () => {
                    solver2.clearAnimations();
                    await solver2.animateLabel('Prime Implicants');
                    for (const coords of result.steps.primeImplicants.coords) {
                        solver2.drawClusterFromCoords(coords, 'group-color'); /* CHANGED from essential-color */
                    }
                };
                
                await animateStep2();
                step2.querySelector('.btn-replay').addEventListener('click', animateStep2);

                // STEP 3: Coverage computation
                const step3 = document.createElement('div');
                step3.className = 'step-container';
                step3.innerHTML = `
                    <div class="step-title">
                        <span>Step 3: Computing Coverage Patterns</span>
                        <button class="btn-replay">üîÑ Replay</button>
                    </div>
                    <div class="step-content">
                        <p><strong>What happens?</strong> For each prime implicant we build a <em>coverage mask</em> retaining only target cells (ignoring pure don't-care positions). This creates a prime‚Äìminterm incidence map.</p>
                        <p><strong>Complexity:</strong> O(|P| ¬∑ n) where |P| is number of prime implicants and n is cell count.</p>
                        <p>Each prime covers these ${targetName} counts:</p>
                        ${result.steps.primeWithCoverage.terms.map((term, i) =>
                            `<p><strong>Prime ${i+1} (${term})</strong> covers ${result.steps.primeWithCoverage.coverageCounts[i]} ${targetName}</p>`).join('')}
                        <!-- ADDED: persistent coverage section -->
                        <div class="info-box" style="margin-top:12px;">
                            Persistent Coverage Map: after the animation, each target cell shows chips ‚ÄúPk‚Äù for the primes covering it (hover to see the prime term).
                        </div>
                        <div class="coverage-legend"></div>
                    </div>
                `;
                viz.querySelector('.visualization').appendChild(step3);
                
                const solver3 = new KMapSolver(state.kmap, state.convention, step3);
                step3.querySelector('.step-content').insertAdjacentHTML('afterbegin', solver3.createAnimatedKmap());
                
                const animateStep3 = async () => {
                    solver3.clearAnimations();
                    solver3.clearCoverageBadges();
                    for (let i = 0; i < result.steps.primeWithCoverage.coords.length; i++) {
                        await solver3.animateLabel(`Prime ${i+1} Coverage`);
                        solver3.drawClusterFromCoords(result.steps.primeWithCoverage.coords[i], 'group-color'); /* CHANGED from covered-color */
                        await solver3.delay(800);
                        solver3.clearAnimations();
                    }
                    // ADDED: render persistent coverage overlay and legend
                    solver3.renderCoverageIncidence(
                        result.steps.primeWithCoverage.coords,
                        result.steps.primeWithCoverage.terms
                    );
                    const legend = step3.querySelector('.coverage-legend');
                    if (legend) {
                        legend.innerHTML = result.steps.primeWithCoverage.terms
                            .map((term, i) => `<div class="group-item">P${i+1}: ${term}</div>`)
                            .join('');
                    }
                };
                
                await animateStep3();
                step3.querySelector('.btn-replay').addEventListener('click', animateStep3);

                // STEP 4: Essential primes
                const step4 = document.createElement('div');
                step4.className = 'step-container';
                step4.innerHTML = `
                    <div class="step-title">
                        <span>Step 4: Finding Essential Prime Implicants</span>
                        <button class="btn-replay">üîÑ Replay</button>
                    </div>
                    <div class="step-content">
                        <p><strong>What happens?</strong> A prime is essential if it alone covers at least one minterm/maxterm. We scan coverage lists; any minterm with a single covering prime marks that prime essential.</p>
                        <p><strong>Complexity:</strong> O(n + |P|) ‚âà O(n) since n is tiny (‚â§16).</p>
                        <p><strong>Found ${result.steps.essentialPrimes.indices.length}</strong> essential prime(s):</p>
                        <div class="group-list">
                            ${result.steps.essentialPrimes.terms.map(term =>
                                `<div class="group-item essential">Essential: ${term}</div>`).join('')}
                        </div>
                    </div>
                `;
                viz.querySelector('.visualization').appendChild(step4);
                
                const solver4 = new KMapSolver(state.kmap, state.convention, step4);
                step4.querySelector('.step-content').insertAdjacentHTML('afterbegin', solver4.createAnimatedKmap());
                
                const animateStep4 = async () => {
                    solver4.clearAnimations();
                    await solver4.animateLabel('Essential Prime Implicants');
                    for (const coords of result.steps.essentialPrimes.coords) {
                        solver4.drawClusterFromCoords(coords, 'group-color'); /* CHANGED from essential-color */
                        await solver4.delay(400);
                    }
                };
                
                await animateStep4();
                step4.querySelector('.btn-replay').addEventListener('click', animateStep4);

                // STEP 5: Greedy set cover
                const step5 = document.createElement('div');
                step5.className = 'step-container';
                step5.innerHTML = `
                    <div class="step-title">
                        <span>Step 5: Greedy Set Cover</span>
                        <button class="btn-replay">üîÑ Replay</button>
                    </div>
                    <div class="step-content">
                        <p><strong>What happens?</strong> Remaining uncovered ${targetName} are handled by repeatedly selecting the prime implicant that covers the largest number of still-uncovered targets. This heuristic is a classic logarithmic approximation to optimal set cover.</p>
                        <p><strong>Complexity:</strong> O(|P| ¬∑ n ¬∑ i) where i ‚â§ number of selections (small). For K-maps this is trivial in practice.</p>
                        <p>Selections:</p>
                        ${
                            result.steps.greedySelections.length
                            ? result.steps.greedySelections.map(sel =>
                                `<p>Added <strong>${sel.term}</strong> covering ${sel.newCoverage} new ${targetName}</p>`).join('')
                            : '<p>‚úÖ All targets already covered by essentials.</p>'
                        }
                    </div>
                `;
                viz.querySelector('.visualization').appendChild(step5);
                
                const solver5 = new KMapSolver(state.kmap, state.convention, step5);
                step5.querySelector('.step-content').insertAdjacentHTML('afterbegin', solver5.createAnimatedKmap());
                
                const animateStep5 = async () => {
                    solver5.clearAnimations();
                    await solver5.animateLabel('Selected Primes');
                    for (const coords of result.steps.finalSelected.coords) {
                        solver5.drawClusterFromCoords(coords, 'group-color'); /* CHANGED from essential-color */
                    }
                };
                
                await animateStep5();
                step5.querySelector('.btn-replay').addEventListener('click', animateStep5);

                // STEP 6: Final result
                const step6 = document.createElement('div');
                step6.className = 'step-container';
                step6.innerHTML = `
                    <div class="step-title">
                        <span>‚ú® Final Minimized Expression</span>
                    </div>
                    <div class="step-content">
                        <p><strong>Assembly & Redundancy Check:</strong> We optionally remove any selected prime whose exclusion does not reduce total coverage (bitmask difference test). This guarantees no superfluous term remains.</p>
                        <p><strong>Redundancy Phase Complexity:</strong> O(|S| ¬∑ n) where |S| is selected implicants. Combined pipeline stays comfortably sub-millisecond for 4-variable maps.</p>
                        <p><strong>Aggregate Complexity Summary:</strong></p>
                        <ul style="margin:0 0 10px 18px;padding:0;">
                            <li>Group Enumeration: O(n ¬∑ |G| ¬∑ s)</li>
                            <li>Prime Filtering: O(|G|¬≤)</li>
                            <li>Coverage Build: O(|P| ¬∑ n)</li>
                            <li>Essentials Detection: O(n)</li>
                            <li>Greedy Cover: O(|P| ¬∑ n ¬∑ i)</li>
                            <li>Redundancy Removal: O(|S| ¬∑ n)</li>
                        </ul>
                        <div class="result">${result.expression}</div>
                        <br>
                        <strong>Final solution uses ${result.steps.finalSelected.terms.length} term(s):</strong>
                        <div class="group-list">
                            ${result.steps.finalSelected.terms.map(term =>
                                `<div class="group-item essential">${term}</div>`).join('')}
                        </div>
                    </div>
                `;
                viz.querySelector('.visualization').appendChild(step6);
                
                const solver6 = new KMapSolver(state.kmap, state.convention, step6);
                step6.querySelector('.step-content').insertAdjacentHTML('afterbegin', solver6.createAnimatedKmap());
                
                solver6.clearAnimations();
                await solver6.animateLabel('Final Solution');
                for (const coords of result.steps.finalSelected.coords) {
                    solver6.drawClusterFromCoords(coords, 'final-color');
                }
                
            } catch (error) {
                viz.innerHTML = `<div class="error"><strong>Error:</strong> ${error.message}<br><br>
                    <strong>Troubleshooting:</strong><br>
                    1. Run: <code>python app.py</code><br>
                    2. Check: http://localhost:5000<br>
                    3. Verify stanlogic is installed</div>`;
            }
        });

        // Initialize on load
        initKMap();
    </script>
</body>
</html>